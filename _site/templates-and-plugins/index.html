<p>In the &#8216;Symbols &amp; duplication&#8217; section, some ways are describe to create multiple, repeating SVG structures:</p>

<ul>
<li>SVG&#8217;s native <code>&lt;symbol&gt;</code> and <code>&lt;use&gt;</code> elements, which are a built-in way to create multiple instances of elements and nested structures. They can be created with Pablo&#8217;s <code>.symbol()</code> and <code>.use()</code> element methods.</li>

<li>The collection methods, <code>.clone()</code> and <code>.duplicate()</code>, to replicate existing SVG elements and nested structures.</li>
</ul>

<p>In addition to these, and described below, there is a <code>Pablo.template()</code>, which allows <em>fine-grained control</em> of each instance of a template structure, and a <code>Pablo.fn</code> object that can be extended to provide new methods to Pablo collections.</p>

<h2 id='id67'><code>Pablo.template(namespace, constructor)</code></h2>

<p>Allows variable, repeatable SVG structures to be created, e.g. polygons, stars, or any other complex collection of elements. Each structures can be assigned a namespace, so that creating new instances is as simple as creating any of the basic SVG elements with Pablo.</p>

<p>Unlike SVG&#8217;s built in <code>&lt;use&gt;</code> and <code>&lt;symbol&gt;</code> elements, <code>Pablo.template()</code> allows <em>fine-grained control</em> of each instance of the template structure.</p>

<p>The method accepts a <code>namespace</code> (e.g. <code>star</code>) and a <code>constructor</code> function that, when called, will create a new instance of the template. The constructor can accept any number arguments (e.g. <code>Pablo.star(&#39;red&#39;, 50, {foo:&#39;bar&#39;})</code>).</p>

<p>As with Pablo element methods, new instances of the namespace can either be created via the <code>Pablo</code> object (e.g. <code>Pablo.star()</code>) or as a new child of an element or collection (e.g. <code>Pablo.g().star()</code>). If the latter, then the <code>this</code> context inside the constructor will be the parent element, otherwise <code>this</code> will be null.</p>

<pre><code>Pablo.template(&#39;star&#39;, function(options){
    var points = options.points || 6,
        size = options.size || 50,
        x = options.x || 0,
        y = options.y || 0,
        theta = 360 / points,
        pathString = &#39;m&#39; + size*1.5 + &#39;,&#39; + size*0.75,
        // Should be 1/points to 0.5*points
        depth = points * 0.375,
        angle = 0, i, x1, y1, x2, y2;

    size = (size * 8) / (points+5.5);
    for (i=0; i&lt;points; i++){
        angle = Math.PI * theta * i / 180; 
        x1 = size * Math.cos(angle); 
        y1 = size * Math.sin(angle);
        angle = Math.PI * theta * (i+depth) / 180; 
        x2 = size * Math.cos(angle); 
        y2 = size * Math.sin(angle);
        pathString += &#39;l&#39;+x1+&#39;,&#39;+y1+&#39;l&#39;+x2+&#39;,&#39;+y2;
    }
    return Pablo.path({
        d: pathString,
        transform: &#39;translate(&#39;+x+&#39;,&#39;+y+&#39;)&#39;
    });
});

var paper = Pablo(demoElement).root({height:120});

// Pablo.star() is now available
Pablo.star({points:5})
    .attr({fill:&#39;red&#39;})
    .appendTo(paper);

// And so is collection.star()
paper.star({points:7, x:120})
    .attr({fill:&#39;orange&#39;});
    
paper.star({points:13, x:245})
    .attr({fill:&#39;blue&#39;});</code></pre>

<h2 id='id68'><code>Pablo.fn</code></h2>

<p>Pablo collections can be given a new method by extending the <code>Pablo.fn</code> object with a Pablo plugin. <code>Pablo.fn</code> is the Pablo collections <code>prototype</code> object, containing all the methods available to collections.</p>

<pre><code>// Create Pablo plugin: - rotate an element by 45 degrees
Pablo.fn.rotate45 = function(value){
    return this.attr(&#39;transform&#39;, &#39;rotate(45)&#39;);
};

var paper = Pablo(demoElement).root({height:110});

paper.rect({width:100, height:50, x:25, y:-25, fill:&#39;blue&#39;})
     .rotate45();

paper.ellipse({cx:125, cy:-60, rx:50, ry:25, fill:&#39;orange&#39;})
     .rotate45();</code></pre>